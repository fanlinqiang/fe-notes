## HTTP 缓存策略

http请求做为影响前端性能极为重要的一环，因为请求受网络影响很大，如果网络很慢的情况下,页面很可能会空白很久。对于首次进入网站的用户可能要通过优化接口性能和接口数量来解决。但是，对于重复进入页面的用户，除了浏览器缓存，http缓存可以很大程度对已经加载过的页面进行优化。

### 强缓存

强缓存两个相关字段，`Expires`，`Cache-Control`。
「强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。」
首先检查强缓存，这个阶段**不需要发送HTTP请求**通过查找不同的字段来进行，不同的HTTP版本所以不同。

HTTP1.0版本，使用的是Expires，HTTP1.1使用的是Cache-Control

#### Expires

Expires即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:

```
# 表示该资源在2020年7月29日11:10:23过期，过期时就会重新向服务器发起请求。
Expires:Mon, 29 Jun 2020 11:10:23 GMT
```

这个方式有一个问题：「服务器的时间和浏览器的时间可能并不一致」，所以HTTP1.1提出新的字段代替它。

#### Cache-Control

这个字段采用的时间是过期时长，对应的是max-age。max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；

|可选值|描述|
|:-|:-|
|no-cache|不使用本地缓存。需要使用协商缓存，无论本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。|
|no-store|直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。|
|public|可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。|
|private|只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。|
|must-revalidate|本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验|

```
# 可以同时使用多个
Cache-Control: no-cache, no-store, must-revalidate
# 代表该资源返回后6000秒，可以直接使用缓存。
Cache-Control:max-age=6000
```

* 当Expires和Cache-Control同时存在时，优先考虑Cache-Control。
* 当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存

### 协商缓存

强缓存失效后，浏览器在请求头中携带响应的缓存Tag来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。
缓存分为两种，`Last-Modified`和 `ETag`。两者各有优势，并不存在谁对谁有绝对的优势，与上面所讲的强缓存两个Tag所不同。

#### Last-Modified/If-Modified-Since

这个字段表示的是**最后修改时间**。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。
服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中该资源的最后修改时间对比:

* 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
* 否则返回304，告诉浏览器直接使用缓存。

#### ETag/If-None-Match

ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。

```
etag: "1d6724068754eab"
```

浏览器接受到ETag值，会在下次请求的时候，将这个值作为`If-None-Match`这个字段的内容，发给服务器。

* 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样
* 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存


#### 两者对比

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

* 性能上，Last-Modified优于ETag，Last-Modified记录的是时间点，而Etag需要根据文件的MD5算法生成对应的hash值。
* 精度上，ETag优于Last-Modified。ETag按照内容给资源带上标识，能准确感知资源变化，Last-Modified在某些场景并不能准确感知变化，比如
    * 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
    * Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

最后，「如果两种方式都支持的话，服务器会优先考虑ETag」。

### 缓存位置

从缓存位置上来看，分为4种，从上往下依次检查是否命中，如果但都没有命中则重新发起请求。

* Service Worker
* Memory Cache
* Disk Cache
* Push Cache

#### Service Worker

是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是`Service Worker Cache`。

#### Memory Cache

指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
内存缓存中有一块重要的缓存资源是preloader相关指令（例如`<link rel="prefetch">`）下载的资源。它可以一边解析js/css文件，一边网络请求下一个资源。

#### Disk Cache

存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。绝大部分的缓存都来自Disk Cache，在HTTP 的协议头中设置。

#### Push Cache
（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

#### Disk Cache VS Memory Cache

两者对比，主要的策略

内容使用率高的话，文件优先进入磁盘

比较大的JS，CSS文件会直接放入磁盘，反之放入内存。
