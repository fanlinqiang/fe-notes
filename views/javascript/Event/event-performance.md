## 内存和性能

### 事件代理（事件委托）
[《JavaScript 事件委托详解》](https://zhuanlan.zhihu.com/p/26536815)

事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。
* 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。
* 并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

### 移除事件处理程序

每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就 会建立一个连接。这种连接越多，页面执行起来就越慢。如前所述，可以采用事件委托技术，限制建立 的连接数量。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那 些过时不用的“空事件处理程序”(dangling event handler)，也是造成 Web 应用程序内存与性能问题的 主要原因。

在两种情况下，可能会造成上述问题。

1. 从文档中移除带有事件处理程序的元素时
2. 卸载页面的时


#### 文档中移除带有事件处理程序的元素时

通过纯粹的 DOM 操作，例如使用 removeChild()和 replaceChild()方法，但更多地是发 生在使用 innerHTML 替换页面中某一部分的时候。如果带有事件处理程序的元素被 innerHTML 删除 了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。

```html
<div id="myDiv">
    <input type="button" value="Click Me" id="myBtn">
</div>
<script type="text/javascript">
    var btn = document.getElementById("myBtn");
    btn.onclick = function(){ //先执行某些操作
        document.getElementById("myDiv").innerHTML = "Processing..."; //麻烦了!
    };
</script>
```

这里，有一个按钮被包含在`<div>`元素中。为避免双击，单击这个按钮时就将按钮移除并替换成一 条消息;这是网站设计中非常流行的一种做法。但问题在于，当按钮被从页面中移除时，它还带着一个 事件处理程序呢。在`<div>`元素上设置 innerHTML 可以把按钮移走，但事件处理程序仍然与按钮保持 着引用关系。有的浏览器(尤其是 IE)在这种情况下不会作出恰当地处理，它们很有可能会将对元素和 对事件处理程序的引用都保存在内存中。如果你知道某个元素即将被移除，那么最好手工移除事件处理 程序，如下面的例子所示。

```html
<div id="myDiv">
     <input type="button" value="Click Me" id="myBtn">
 </div>
 <script type="text/javascript">
     var btn = document.getElementById("myBtn");
     btn.onclick = function(){ //先执行某些操作
         btn.onclick = null; //移除事件处理程序
         document.getElementById("myDiv").innerHTML = "Processing...";
     };
 </script>
```

!> 注意，在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提。

!> 采用事件委托也有助于解决这个问题。如果事先知道将来有可能使用 innerHTML 替换掉页面中的某一部分，那么就可以不直接把事件处理程序添加到该部分的元素 中。而通过把事件处理程序指定给较高层次的元素，同样能够处理该区域中的事件。


#### 卸载页面的时

IE8 及更早版本在这种情况下依然是问题最多的浏览器，尽管其他浏览器或多或少也有类似的问题。如果在页面被卸载之前没 有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面再卸载页面时(可能是在两个页 19 面间来回切换，也可以是单击了“刷新”按钮)，内存中滞留的对象数目就会增加，因为事件处理程序 占用的内存并没有被释放。
一般来说，最好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。 7在此，事件委托技术再次表现出它的优势——需要跟踪的事件处理程序越少，移除它们就越容易。对这 种类似撤销的操作，我们可以把它想象成:只要是通过 onload 事件处理程序添加的东西，最后都要通过 onunload 事件处理程序将它们移除。
